// ===== FILE: modules/callhandler/src/main/kotlin/com/jarvismini/callhandler/logic/CallHandlerEngine.kt =====
package com.jarvismini.callhandler.logic

import android.content.Context
import android.provider.ContactsContract
import android.telephony.SmsManager
import android.util.Log
import com.jarvismini.automation.decision.ReplyDecision
import com.jarvismini.automation.input.AutoReplyInput
import com.jarvismini.automation.orchestrator.AutoReplyOrchestrator
import com.jarvismini.core.JarvisMode
import com.jarvismini.core.JarvisState
import java.util.concurrent.ConcurrentHashMap

object CallHandlerEngine {

    private const val TAG = "CALL-HANDLER"
    private const val COOLDOWN_MS = 60_000L

    private val lastHandled = ConcurrentHashMap<String, Long>()

    fun handleIncomingCall(context: Context, number: String) {
        val now = System.currentTimeMillis()

        // üîï Jarvis OFF ‚Üí do nothing
        if (JarvisState.currentMode == JarvisMode.NORMAL) {
            Log.d(TAG, "NORMAL mode ‚Üí allow call")
            return
        }

        // üîí Contacts only
        if (!isSavedContact(context, number)) {
            Log.d(TAG, "Ignored (not contact)")
            return
        }

        // üîÅ Cooldown
        val last = lastHandled[number] ?: 0L
        if (now - last < COOLDOWN_MS) {
            Log.d(TAG, "Cooldown active")
            return
        }
        lastHandled[number] = now

        // üß† Orchestrator decision
        val decision = AutoReplyOrchestrator.handle(
            AutoReplyInput(
                messageText = "Incoming call",
                isFromOwner = false
            )
        )

        if (decision is ReplyDecision.AutoReply) {
            sendSms(number, decision.message)
            Log.d(TAG, "Auto-reply sent")
        }
    }

    private fun isSavedContact(context: Context, number: String): Boolean {
        val uri = ContactsContract.PhoneLookup.CONTENT_FILTER_URI
        val cursor = context.contentResolver.query(
            uri,
            arrayOf(ContactsContract.PhoneLookup.NUMBER),
            "${ContactsContract.PhoneLookup.NUMBER} = ?",
            arrayOf(number),
            null
        )
        return cursor?.use { it.moveToFirst() } == true
    }

    private fun sendSms(number: String, message: String) {
        SmsManager.getDefault().sendTextMessage(number, null, message, null, null)
    }
}
// ===== FILE: modules/callhandler/src/main/kotlin/com/jarvismini/callhandler/receiver/CallReceiver.kt =====
package com.jarvismini.callhandler.receiver

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.telephony.TelephonyManager
import com.jarvismini.callhandler.logic.CallHandlerEngine

class CallReceiver : BroadcastReceiver() {

    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action != TelephonyManager.ACTION_PHONE_STATE_CHANGED) return

        val state = intent.getStringExtra(TelephonyManager.EXTRA_STATE)
        val number = intent.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER)

        if (state == TelephonyManager.EXTRA_STATE_RINGING && !number.isNullOrBlank()) {
            CallHandlerEngine.handleIncomingCall(context, number)
        }
    }
}
