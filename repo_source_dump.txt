================================
FILE TREE (SELECTED FOLDERS)
================================

.
â”œâ”€â”€ app
â”‚   â”œâ”€â”€ build.gradle.kts
â”‚   â”œâ”€â”€ keystore
â”‚   â”œâ”€â”€ proguard-rules.pro
â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”œâ”€â”€ androidTest
â”‚   â”‚   â”‚   â”œâ”€â”€ java
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ com
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ jarvismini
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ExampleAndroidTest.kt
â”‚   â”‚   â”œâ”€â”€ debug
â”‚   â”‚   â”‚   â”œâ”€â”€ java
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ com
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ jarvismini
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DebugBuildConfig.kt
â”‚   â”‚   â”œâ”€â”€ main
â”‚   â”‚   â”‚   â”œâ”€â”€ AndroidManifest.xml
â”‚   â”‚   â”‚   â”œâ”€â”€ kotlin
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ com
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ jarvismini
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AppAccessibilityService.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ BuildConfigBridge.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CoreApp.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MainActivity.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ res
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ layout
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ activity_main.xml
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ activity_settings.xml
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ values
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ colors.xml
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ strings.xml
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ themes.xml
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ xml
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ accessibility_service.xml
â”‚   â”‚   â”œâ”€â”€ test
â”‚   â”‚   â”‚   â”œâ”€â”€ java
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ com
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ jarvismini
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ExampleUnitTest.kt
â”œâ”€â”€ modules
â”‚   â”œâ”€â”€ automation
â”‚   â”‚   â”œâ”€â”€ build.gradle.kts
â”‚   â”‚   â”œâ”€â”€ proguard-rules.pro
â”‚   â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”‚   â”œâ”€â”€ main
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AndroidManifest.xml
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ kotlin
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ com
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ jarvismini
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ automation
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AccessibilityServiceHelper.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AppAutomationService.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AutoCloser.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AutoReplyContext.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AutomationEngine.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AutomationStubs.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ChatOpener.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ JarvisNotificationService.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MessageExtractor.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MessageSender.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ModeGuard.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ NodeFinder.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SmartAutoReply.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ decision
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ReplyDecision.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ input
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AutoReplyInput.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ orchestrator
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AutoReplyOrchestrator.kt
â”‚   â”œâ”€â”€ core
â”‚   â”‚   â”œâ”€â”€ build.gradle.kts
â”‚   â”‚   â”œâ”€â”€ proguard-rules.pro
â”‚   â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”‚   â”œâ”€â”€ main
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AndroidManifest.xml
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ kotlin
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ com
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ jarvismini
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ core
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AssistantProfile.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AssistantVoice.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CoreAppBridge.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Extensions.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ JarvisMode.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ JarvisState.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Logger.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ TimeUtils.kt
â”‚   â”œâ”€â”€ engine
â”‚   â”‚   â”œâ”€â”€ build.gradle.kts
â”‚   â”‚   â”œâ”€â”€ proguard-rules.pro
â”‚   â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”‚   â”œâ”€â”€ main
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AndroidManifest.xml
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ kotlin
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ com
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ jarvismini
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ engine
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CommandEngine.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CoreTag.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ EngineProvider.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ EngineResult.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ JarvisReplyGenerator.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ LLMEngine.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ReplyReason.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ReplyToneResolver.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ StubCommandEngine.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ StubLLMEngine.kt
â”‚   â”œâ”€â”€ smart
â”‚   â”‚   â”œâ”€â”€ build.gradle.kts
â”‚   â”‚   â”œâ”€â”€ proguard-rules.pro
â”‚   â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”‚   â”œâ”€â”€ main
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AndroidManifest.xml
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ kotlin
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ com
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ jarvismini
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ smart
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ChatTypeDetector.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CooldownManager.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ GroupDetection.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RateLimiter.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SleepMode.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SmartFilters.kt
â”‚   â”œâ”€â”€ ui
â”‚   â”‚   â”œâ”€â”€ MainActivity.kt
â”‚   â”‚   â”œâ”€â”€ build.gradle.kts
â”‚   â”‚   â”œâ”€â”€ proguard-rules.pro
â”‚   â”‚   â”œâ”€â”€ src
â”‚   â”‚   â”‚   â”œâ”€â”€ main
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AndroidManifest.xml
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ kotlin
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ com
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ jarvismini
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ui
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DebugPanel.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ViewBindings.kt
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ settings
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SettingsActivity.kt
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ res
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ layout
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ activity_main.xml
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ values
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ styles.xml
â”œâ”€â”€ gradle/wrapper
â”‚   â”œâ”€â”€ gradle-wrapper.properties
â”œâ”€â”€ scripts
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ error_parser.py
â”‚   â”œâ”€â”€ extract_repo_to_txt.py
â”‚   â”œâ”€â”€ git_utils.py
â”‚   â”œâ”€â”€ github.py
â”‚   â”œâ”€â”€ llm.py
â”‚   â”œâ”€â”€ logger.py
â”‚   â”œâ”€â”€ openrouter.py
â”‚   â”œâ”€â”€ patch_applier.py
â”‚   â”œâ”€â”€ pr_utils.py

================================
SOURCE CODE
================================

===== FILE: app/build.gradle.kts =====
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.jarvismini"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.jarvismini"
        minSdk = 26
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"
    }

    buildFeatures {
        viewBinding = true
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}

dependencies {
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.appcompat:appcompat:1.6.1")
    implementation("com.google.android.material:material:1.11.0")

    implementation(project(":modules:core"))
    implementation(project(":modules:automation"))
    implementation(project(":modules:engine"))
    implementation(project(":modules:smart"))
    implementation(project(":modules:ui"))
}


===== FILE: app/proguard-rules.pro =====


===== FILE: app/src/androidTest/java/com/jarvismini/ExampleAndroidTest.kt =====


===== FILE: app/src/debug/java/com/jarvismini/DebugBuildConfig.kt =====


===== FILE: app/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.jarvismini">
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />

    <application
        android:label="@string/app_name"
        android:icon="@android:drawable/sym_def_app_icon"
        android:allowBackup="true"
        android:supportsRtl="true"
        android:theme="@style/Theme.JarvisMini">

        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!-- Accessibility Service -->
        <service
    android:name="com.jarvismini.automation.AppAutomationService"
    android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"
    android:exported="true">

    <intent-filter>
        <action android:name="android.accessibilityservice.AccessibilityService" />
    </intent-filter>

    <meta-data
        android:name="android.accessibilityservice"
        android:resource="@xml/accessibility_service" />
</service>
    </application>

</manifest>


===== FILE: app/src/main/kotlin/com/jarvismini/AppAccessibilityService.kt =====
package com.jarvismini

import android.accessibilityservice.AccessibilityService
import android.util.Log
import android.view.accessibility.AccessibilityEvent
import com.jarvismini.automation.input.AutoReplyInput
import com.jarvismini.automation.orchestrator.AutoReplyOrchestrator
import com.jarvismini.automation.decision.ReplyDecision

class AppAccessibilityService : AccessibilityService() {

    override fun onServiceConnected() {
        super.onServiceConnected()
        Log.i("JarvisService", "Accessibility Service CONNECTED")
    }

    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
        if (event == null) return

        Log.d(
            "JarvisService",
            "Event: ${event.eventType} | Package: ${event.packageName}"
        )

        // TEMP: Only observe WhatsApp
        if (event.packageName != "com.whatsapp") return

        val text = event.text?.joinToString(" ") ?: return
        if (text.isBlank()) return

        val decision = AutoReplyOrchestrator.handle(
            AutoReplyInput(
                messageText = text,
                isFromOwner = false
            )
        )

        when (decision) {
            is ReplyDecision.AutoReply ->
                Log.i("JarvisService", "AutoReply decided: ${decision.message}")

            ReplyDecision.NoReply ->
                Log.i("JarvisService", "No reply decision")
        }
    }

    override fun onInterrupt() {
        Log.w("JarvisService", "Accessibility Service INTERRUPTED")
    }
}


===== FILE: app/src/main/kotlin/com/jarvismini/BuildConfigBridge.kt =====
package com.jarvismini

object BuildConfigBridge {
    const val IS_DEBUG = true
}


===== FILE: app/src/main/kotlin/com/jarvismini/CoreApp.kt =====
package com.jarvismini

import android.app.Application
import com.jarvismini.automation.orchestrator.AutoReplyOrchestrator
import com.jarvismini.core.JarvisMode
import com.jarvismini.core.JarvisState

class CoreApp : Application() {

    override fun onCreate() {
        super.onCreate()

        // Explicit default mode
        JarvisState.currentMode = JarvisMode.NORMAL

        AutoReplyOrchestrator.init()

        println("CoreApp started with mode: ${JarvisState.currentMode}")
    }
}


===== FILE: app/src/main/kotlin/com/jarvismini/MainActivity.kt =====
package com.jarvismini

import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.view.View
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import com.jarvismini.automation.decision.ReplyDecision
import com.jarvismini.automation.input.AutoReplyInput
import com.jarvismini.automation.orchestrator.AutoReplyOrchestrator
import com.jarvismini.core.JarvisMode
import com.jarvismini.core.JarvisState

class MainActivity : AppCompatActivity() {

    private lateinit var statusText: TextView
    private lateinit var simulateButton: Button
    private lateinit var modeSpinner: Spinner

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // âš ï¸ Request notification permission for Android 13+
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            if (checkSelfPermission(android.Manifest.permission.POST_NOTIFICATIONS)
                != PackageManager.PERMISSION_GRANTED
            ) {
                requestPermissions(
                    arrayOf(android.Manifest.permission.POST_NOTIFICATIONS),
                    1001
                )
            }
        }

        // Status text
        statusText = TextView(this).apply {
            textSize = 16f
            text = "Current mode: ${JarvisState.currentMode}"
            setPadding(24, 24, 24, 24)
        }

        // Spinner
        modeSpinner = Spinner(this)
        val modes = JarvisMode.values().map { it.name }
        val adapter = ArrayAdapter(
            this,
            android.R.layout.simple_spinner_item,
            modes
        )
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        modeSpinner.adapter = adapter

        modeSpinner.onItemSelectedListener =
            object : AdapterView.OnItemSelectedListener {
                override fun onItemSelected(
                    parent: AdapterView<*>,
                    view: View?,
                    position: Int,
                    id: Long
                ) {
                    val selectedMode = JarvisMode.valueOf(modes[position])
                    JarvisState.currentMode = selectedMode
                    statusText.text = "Current mode: $selectedMode"
                }

                override fun onNothingSelected(parent: AdapterView<*>) {}
            }

        // Button
        simulateButton = Button(this).apply {
            text = "Simulate Incoming Message"
            setOnClickListener { simulateIncomingMessage() }
        }

        // Layout
        val layout = LinearLayout(this).apply {
            orientation = LinearLayout.VERTICAL
            addView(statusText)
            addView(modeSpinner)
            addView(simulateButton)
        }

        setContentView(layout)
    }

    private fun simulateIncomingMessage() {
        val input = AutoReplyInput(
            messageText = "Hello Jarvis! Are you there?",
            isFromOwner = false
        )

        val decision = AutoReplyOrchestrator.handle(input)

        statusText.text = when (decision) {
            is ReplyDecision.AutoReply ->
                "AutoReply: ${decision.message}"
            ReplyDecision.NoReply ->
                "No reply decision made"
        }
    }

    // Handle permission result (optional logging)
    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == 1001) {
            if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                Toast.makeText(this, "Notification permission granted", Toast.LENGTH_SHORT).show()
            } else {
                Toast.makeText(this, "Notification permission denied", Toast.LENGTH_SHORT).show()
            }
        }
    }
}


===== FILE: app/src/main/res/layout/activity_main.xml =====
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

</LinearLayout>


===== FILE: app/src/main/res/layout/activity_settings.xml =====
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:padding="24dp"
    android:gravity="center"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Spinner
        android:id="@+id/modelSpinner"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:padding="12dp" />

</LinearLayout>


===== FILE: app/src/main/res/values/colors.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#BB86FC</color>
    <color name="purple_500">#6200EE</color>
    <color name="purple_700">#3700B3</color>
    <color name="teal_200">#03DAC5</color>
    <color name="black">#000000</color>
    <color name="white">#FFFFFF</color>
</resources>


===== FILE: app/src/main/res/values/strings.xml =====
<resources>
  <string name="app_name">Jarvis Merged</string>
  <string name="service_desc">Jarvis automation service for WhatsApp reply.</string>
</resources>


===== FILE: app/src/main/res/values/themes.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <style name="Theme.JarvisMerged" parent="Theme.Material3.DayNight.NoActionBar">
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="android:navigationBarColor">@android:color/black</item>
    </style>

</resources>


===== FILE: app/src/main/res/xml/accessibility_service.xml =====
<?xml version="1.0" encoding="utf-8"?>
<accessibility-service
    xmlns:android="http://schemas.android.com/apk/res/android"

    android:accessibilityEventTypes="typeAllMask"

    android:accessibilityFeedbackType="feedbackGeneric"

    android:accessibilityFlags="
        flagReportViewIds
        | flagRetrieveInteractiveWindows
        | flagIncludeNotImportantViews"

    android:canRetrieveWindowContent="true"
    android:notificationTimeout="50"
    android:description="@string/service_desc" />


===== FILE: app/src/test/java/com/jarvismini/ExampleUnitTest.kt =====


===== FILE: modules/automation/build.gradle.kts =====
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.jarvismini.automation"
    compileSdk = 34

    defaultConfig {
        minSdk = 23
        targetSdk = 34
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}

dependencies {
    implementation(project(":modules:smart"))
    implementation(project(":modules:engine"))
    implementation(project(":modules:core"))
    implementation("androidx.core:core-ktx:1.12.0")
}


===== FILE: modules/automation/proguard-rules.pro =====


===== FILE: modules/automation/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" />


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/AccessibilityServiceHelper.kt =====
package com.jarvismini.automation

import android.accessibilityservice.AccessibilityService
import android.view.accessibility.AccessibilityNodeInfo

object AccessibilityServiceHelper {
    lateinit var service: AccessibilityService

    fun init(s: AccessibilityService) {
        service = s
    }

    fun getRootNode(): AccessibilityNodeInfo? {
        return service.rootInActiveWindow
    }
}


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/AppAutomationService.kt =====
package com.jarvismini.automation

import android.accessibilityservice.AccessibilityService
import android.app.NotificationManager
import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.util.Log
import android.view.accessibility.AccessibilityEvent
import android.view.accessibility.AccessibilityNodeInfo

class AppAutomationService : AccessibilityService() {

    private val TAG = "JarvisMini"
    private val TARGET_PACKAGE = "com.whatsapp"
    private var lastSeenMessage: String? = null

    override fun onServiceConnected() {
        Log.i(TAG, "âœ… Accessibility Service CONNECTED")
    }

    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
        if (event == null) return

        when (event.eventType) {
            AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED -> {
                handleNotificationEvent(event)
            }

            AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED -> {
                handleWindowContentChanged(event)
            }
        }
    }

    private fun handleNotificationEvent(event: AccessibilityEvent) {
        val pkg = event.packageName?.toString() ?: return
        if (pkg != TARGET_PACKAGE) return

        val notificationText = event.text.joinToString(" ")
        Log.i(TAG, "ðŸ“¢ WhatsApp Notification: $notificationText")

        // Launch WhatsApp to read & reply
        val intent = packageManager.getLaunchIntentForPackage(TARGET_PACKAGE)
        intent?.flags = Intent.FLAG_ACTIVITY_NEW_TASK
        startActivity(intent)
    }

    private fun handleWindowContentChanged(event: AccessibilityEvent) {
        val pkg = event.packageName?.toString() ?: return
        if (pkg != TARGET_PACKAGE) return

        val root = rootInActiveWindow ?: return
        val message = extractLatestMessage(root) ?: return

        if (message == lastSeenMessage) return
        lastSeenMessage = message

        Log.i(TAG, "ðŸ“© NEW MESSAGE: $message")

        // Auto-reply
        sendReply(root, "Hello, Jarvis here!")
    }

    private fun extractLatestMessage(root: AccessibilityNodeInfo): String? {
        val queue = ArrayDeque<AccessibilityNodeInfo>()
        queue.add(root)
        var latestText: String? = null

        while (queue.isNotEmpty()) {
            val node = queue.removeFirst()
            if (node.className == "android.widget.TextView") {
                val text = node.text?.toString()
                if (!text.isNullOrBlank() && text.length < 500) {
                    latestText = text
                }
            }
            for (i in 0 until node.childCount) {
                node.getChild(i)?.let { queue.add(it) }
            }
        }
        return latestText
    }

    private fun sendReply(root: AccessibilityNodeInfo, message: String) {
        val inputField = NodeFinder.findInputField(root)
        val sendButton = NodeFinder.findSendButton(root)

        if (inputField == null || sendButton == null) {
            Log.w(TAG, "âŒ Input or Send button not found")
            return
        }

        val args = Bundle().apply {
            putCharSequence(
                AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE,
                message
            )
        }

        inputField.performAction(AccessibilityNodeInfo.ACTION_SET_TEXT, args)
        sendButton.performAction(AccessibilityNodeInfo.ACTION_CLICK)

        Log.i(TAG, "âœ… AUTO-REPLY SENT: $message")
    }

    override fun onInterrupt() {
        Log.w(TAG, "âš ï¸ Accessibility Interrupted")
    }
}


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/AutoCloser.kt =====
package com.jarvismini.automation

import android.view.accessibility.AccessibilityNodeInfo

object AutoCloser {
    fun closeChat(root: AccessibilityNodeInfo?) {
        val back = try {
            root?.findAccessibilityNodeInfosByViewId("com.whatsapp:id/back")
        } catch (_: Exception) { null }

        if (!back.isNullOrEmpty()) {
            back.first().performAction(AccessibilityNodeInfo.ACTION_CLICK)
        }
    }
}

===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/AutoReplyContext.kt =====
package com.jarvismini.automation

import com.jarvismini.engine.ReplyReason
import com.jarvismini.core.JarvisMode

data class AutoReplyContext(
    val reason: ReplyReason,
    val currentMode: JarvisMode,
    val isImportant: Boolean = false
)


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/AutomationEngine.kt =====
package com.jarvismini.automation

class AutomationEngine {

    fun generateReply(input: String): String {
        // STUB: real logic will come later
        return ""
    }

}


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/AutomationStubs.kt =====
package com.jarvismini.automation

fun ChatAllowed(): Boolean = false
fun generateReply(text: String): String = ""

===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/ChatOpener.kt =====
package com.jarvismini.automation

import android.accessibilityservice.AccessibilityService
import android.util.Log
import android.view.accessibility.AccessibilityNodeInfo

object ChatOpener {

    private const val TAG = "JarvisMini-ChatOpener"

    private val unreadBadgeIds = listOf(
        "com.whatsapp:id/unread_indicator",
        "com.whatsapp:id/unread_count",
        "com.whatsapp:id/message_count"
    )

    fun openChat(service: AccessibilityService, root: AccessibilityNodeInfo?) {
        root ?: return

        // Try â€œnew messageâ€
        val nodes = root.findAccessibilityNodeInfosByText("new message")
        if (!nodes.isNullOrEmpty()) {
            nodes.first().performAction(AccessibilityNodeInfo.ACTION_CLICK)
            Log.i(TAG, "Opened chat via 'new message'")
            return
        }

        // Try unread badge
        for (id in unreadBadgeIds) {
            try {
                val badges = root.findAccessibilityNodeInfosByViewId(id)
                if (!badges.isNullOrEmpty()) {
                    badges.first().performAction(AccessibilityNodeInfo.ACTION_CLICK)
                    Log.i(TAG, "Opened chat via unread badge: $id")
                    return
                }
            } catch (_: Exception) {}
        }
    }
}

===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/JarvisNotificationService.kt =====
package com.jarvismini.automation

import android.app.Notification
import android.service.notification.NotificationListenerService
import android.service.notification.StatusBarNotification
import android.util.Log
import android.view.accessibility.AccessibilityNodeInfo
import com.jarvismini.automation.decision.ReplyDecision
import com.jarvismini.automation.input.AutoReplyInput
import com.jarvismini.automation.orchestrator.AutoReplyOrchestrator

class JarvisNotificationService : NotificationListenerService() {

    private val TAG = "JarvisNotifService"

    override fun onNotificationPosted(sbn: StatusBarNotification) {
        val packageName = sbn.packageName
        if (packageName != "com.whatsapp") return

        val notification = sbn.notification
        val extras = notification.extras
        val messageText = extras.getCharSequence(Notification.EXTRA_TEXT)?.toString()?.trim()
        val sender = extras.getCharSequence(Notification.EXTRA_TITLE)?.toString()?.trim()

        if (messageText.isNullOrEmpty() || sender.isNullOrEmpty()) return

        Log.i(TAG, "Notification from $sender: $messageText")

        val input = AutoReplyInput(
            messageText = messageText,
            isFromOwner = false
        )

        val decision = AutoReplyOrchestrator.handle(input)

        when (decision) {
            is ReplyDecision.AutoReply -> {
                Log.i(TAG, "Jarvis AutoReply: ${decision.message}")
                // Open chat and send message
                val root = AccessibilityServiceHelper.getRootNode() // helper to get root node
                ChatOpener.openChat(AccessibilityServiceHelper.service, root)
                MessageSender.sendMessage(root, decision.message)
            }

            ReplyDecision.NoReply -> {
                Log.i(TAG, "Jarvis will not reply")
            }
        }

        // Auto-close chat
        val root = AccessibilityServiceHelper.getRootNode()
        AutoCloser.closeChat(root)
    }

    override fun onNotificationRemoved(sbn: StatusBarNotification?) {}
}


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/MessageExtractor.kt =====
package com.jarvismini.automation

import android.view.accessibility.AccessibilityNodeInfo

object MessageExtractor {

    private val chatTitleIds = listOf(
        "com.whatsapp:id/conversation_contact_name",
        "com.whatsapp:id/contact_name",
        "com.whatsapp:id/toolbar_title"
    )

    private val incomingMessageIds = listOf(
        "com.whatsapp:id/message_text",
        "com.whatsapp:id/message_text_in"
    )

    fun getSenderName(root: AccessibilityNodeInfo): String {
        chatTitleIds.forEach { id ->
            try {
                val list = root.findAccessibilityNodeInfosByViewId(id)
                if (!list.isNullOrEmpty()) {
                    return list.first().text?.toString()?.trim() ?: ""
                }
            } catch (_: Exception) {}
        }
        return ""
    }

    fun getLastIncomingMessage(root: AccessibilityNodeInfo): String {
        for (id in incomingMessageIds) {
            try {
                val nodes = root.findAccessibilityNodeInfosByViewId(id)
                if (!nodes.isNullOrEmpty()) {
                    return nodes.last().text?.toString() ?: ""
                }
            } catch (_: Exception) {}
        }
        return ""
    }
}

===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/MessageSender.kt =====
package com.jarvismini.automation

import android.view.accessibility.AccessibilityNodeInfo

object MessageSender {
    fun sendMessage(root: AccessibilityNodeInfo?, message: String) {
        root ?: return
        try {
            val inputField = NodeFinder.findInputField(root)
            inputField?.let {
                val args = android.os.Bundle()
                args.putCharSequence(android.view.accessibility.AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, message)
                it.performAction(AccessibilityNodeInfo.ACTION_SET_TEXT, args)
                it.performAction(AccessibilityNodeInfo.ACTION_CLICK)
            }
        } catch (_: Exception) {}
    }
}


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/ModeGuard.kt =====
package com.jarvismini.automation

import com.jarvismini.core.JarvisMode
import com.jarvismini.core.JarvisState

object ModeGuard {

    fun allowsReply(): Boolean {
        return when (JarvisState.currentMode) {
            JarvisMode.NORMAL -> true
            JarvisMode.WORK -> true
            JarvisMode.DRIVING -> true
            JarvisMode.SLEEP -> false
            JarvisMode.FOCUS -> false
        }
    }
}

===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/NodeFinder.kt =====
package com.jarvismini.automation

import android.util.Log
import android.view.accessibility.AccessibilityNodeInfo

object NodeFinder {

    private const val TAG = "JarvisMini-NodeFinder"

    private val inputIds = listOf(
        "com.whatsapp:id/entry",
        "com.whatsapp:id/voice_note_text_input",
        "com.whatsapp:id/entry_container",
        "com.whatsapp:id/entry_text",
        "com.whatsapp:id/entry_input"
    )

    private val sendButtonIds = listOf(
        "com.whatsapp:id/send",
        "com.whatsapp:id/send_btn",
        "com.whatsapp:id/send_button",
        "com.whatsapp:id/send_icon",
        "com.whatsapp:id/send_message"
    )

    fun findInputField(root: AccessibilityNodeInfo): AccessibilityNodeInfo? {
        for (id in inputIds) {
            safeFindById(root, id)?.firstOrNull()?.let { return it }
        }

        findByClass(root, "android.widget.EditText")?.let { return it }

        for (id in inputIds) {
            safeFindById(root, id)?.firstOrNull()?.parent?.let { parent ->
                if (parent.className?.contains("EditText") == true) return parent
            }
        }

        Log.w(TAG, "Input field not found")
        return null
    }

    fun findSendButton(root: AccessibilityNodeInfo): AccessibilityNodeInfo? {
        for (id in sendButtonIds) {
            safeFindById(root, id)?.firstOrNull()?.let { return it }
        }

        findByClass(root, "android.widget.ImageButton")?.let { return it }

        Log.w(TAG, "Send button not found")
        return null
    }

    private fun safeFindById(node: AccessibilityNodeInfo, id: String): List<AccessibilityNodeInfo>? {
        return try { node.findAccessibilityNodeInfosByViewId(id) } catch (_: Exception) { null }
    }

    private fun findByClass(node: AccessibilityNodeInfo, className: String): AccessibilityNodeInfo? {
        if (node.className == className) return node
        for (i in 0 until node.childCount) {
            val child = node.getChild(i) ?: continue
            findByClass(child, className)?.let { return it }
        }
        return null
    }
}

===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/SmartAutoReply.kt =====
package com.jarvismini.automation

/**
 * STUB implementation.
 * Engine / LLM will be wired later.
 */
object SmartAutoReply {

    suspend fun generate(message: String): String {
        // TODO: connect to engine later
        return ""
    }
}


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/decision/ReplyDecision.kt =====
package com.jarvismini.automation.decision

/**
 * Final decision returned by automation layer.
 */
sealed class ReplyDecision {

    /**
     * Jarvis should auto-reply with this message.
     */
    data class AutoReply(
        val message: String
    ) : ReplyDecision()

    /**
     * Jarvis should not reply.
     */
    object NoReply : ReplyDecision()
}


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/input/AutoReplyInput.kt =====
package com.jarvismini.automation.input

data class AutoReplyInput(
    val messageText: String,
    val senderName: String = "",
    val isFromOwner: Boolean = false
)


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/orchestrator/AutoReplyOrchestrator.kt =====
package com.jarvismini.automation.orchestrator

import com.jarvismini.automation.decision.ReplyDecision
import com.jarvismini.automation.input.AutoReplyInput
import com.jarvismini.core.AssistantVoice
import com.jarvismini.core.JarvisMode
import com.jarvismini.core.JarvisState

/**
 * Orchestrates automation decisions for incoming messages.
 * Pure decision layer â€” no hardcoded user-facing text.
 */
object AutoReplyOrchestrator {

    fun handle(input: AutoReplyInput): ReplyDecision {
        return when (JarvisState.currentMode) {

            JarvisMode.DRIVING ->
                ReplyDecision.AutoReply(
                    message = AssistantVoice.driving()
                )

            JarvisMode.WORK ->
                ReplyDecision.AutoReply(
                    message = AssistantVoice.working()
                )

            JarvisMode.SLEEP ->
                ReplyDecision.AutoReply(
                    message = AssistantVoice.unavailable("sleeping")
                )

            JarvisMode.FOCUS ->
                ReplyDecision.AutoReply(
                    message = AssistantVoice.unavailable("focus mode")
                )

            JarvisMode.NORMAL ->
                ReplyDecision.NoReply
        }
    }

    fun init() {
        // reserved for future signal wiring
    }
}


===== FILE: modules/core/build.gradle.kts =====
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.jarvismini.core"
    compileSdk = 34

    defaultConfig {
        minSdk = 23
        targetSdk = 34
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}


===== FILE: modules/core/proguard-rules.pro =====


===== FILE: modules/core/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" />


===== FILE: modules/core/src/main/kotlin/com/jarvismini/core/AssistantProfile.kt =====
package com.jarvismini.core

object AssistantProfile {

    const val ASSISTANT_NAME = "Jarvis"

    // Default addressing (as you requested)
    const val USER_PRIMARY = "Aamir Sir"
    const val USER_FORMAL = "Mr Shams"

    // Used everywhere
    fun addressUser(): String = USER_PRIMARY
}


===== FILE: modules/core/src/main/kotlin/com/jarvismini/core/AssistantVoice.kt =====
package com.jarvismini.core

object AssistantVoice {

    fun driving(): String =
        "${AssistantProfile.ASSISTANT_NAME}: ${AssistantProfile.addressUser()} is currently driving and will respond shortly."

    fun working(): String =
        "${AssistantProfile.ASSISTANT_NAME}: ${AssistantProfile.addressUser()} is working at the moment. Jarvis will notify him."

    fun unavailable(reason: String): String =
        "${AssistantProfile.ASSISTANT_NAME}: ${AssistantProfile.addressUser()} is unavailable right now ($reason)."

    fun noReply(): String =
        "${AssistantProfile.ASSISTANT_NAME}: No reply will be sent at this time."
}


===== FILE: modules/core/src/main/kotlin/com/jarvismini/core/CoreAppBridge.kt =====
package com.jarvismini.core
object CoreAppBridge { fun appName() = "JarvisMerged" }


===== FILE: modules/core/src/main/kotlin/com/jarvismini/core/Extensions.kt =====
package com.jarvismini.core

fun String.trunc(n: Int): String =
    if (this.length > n) this.substring(0, n) else this


===== FILE: modules/core/src/main/kotlin/com/jarvismini/core/JarvisMode.kt =====
package com.jarvismini.core

enum class JarvisMode {
    NORMAL,
    WORK,
    DRIVING,
    SLEEP,
    FOCUS
}


===== FILE: modules/core/src/main/kotlin/com/jarvismini/core/JarvisState.kt =====
package com.jarvismini.core

object JarvisState {
    var currentMode: JarvisMode = JarvisMode.NORMAL
}


===== FILE: modules/core/src/main/kotlin/com/jarvismini/core/Logger.kt =====
package com.jarvismini.core

object Logger {
    fun i(tag: String, msg: String?) {
        android.util.Log.i(tag, msg ?: "")
    }
}


===== FILE: modules/core/src/main/kotlin/com/jarvismini/core/TimeUtils.kt =====
package com.jarvismini.core
object TimeUtils { fun nowMs() = System.currentTimeMillis() }


===== FILE: modules/engine/build.gradle.kts =====
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.jarvismini.engine"
    compileSdk = 34

    defaultConfig {
        minSdk = 24
        targetSdk = 34
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}

dependencies {
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3")
    implementation(project(":modules:core"))
}


===== FILE: modules/engine/proguard-rules.pro =====


===== FILE: modules/engine/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" />


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/CommandEngine.kt =====
package com.jarvismini.engine

interface CommandEngine {
    fun canHandle(input: String): Boolean
    fun handle(input: String): EngineResult
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/CoreTag.kt =====
package com.jarvismini.engine

object CoreTag {
    const val ENGINE = "ENGINE"
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/EngineProvider.kt =====
package com.jarvismini.engine

object EngineProvider {

    val commandEngine: CommandEngine = StubCommandEngine
    val llmEngine: LLMEngine = StubLLMEngine
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/EngineResult.kt =====
package com.jarvismini.engine

sealed class EngineResult {

    data class Success(
        val reply: String
    ) : EngineResult()

    object Unhandled : EngineResult()
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/JarvisReplyGenerator.kt =====
package com.jarvismini.engine

import com.jarvismini.core.JarvisMode

object JarvisReplyGenerator {

    fun generate(
        incomingMessage: String,
        reason: ReplyReason,
        mode: JarvisMode
    ): String {

        val baseReply = ReplyToneResolver.resolve(reason, mode)

        return "$baseReply\n\nMessage received: \"$incomingMessage\""
    }
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/LLMEngine.kt =====
package com.jarvismini.engine

import android.content.Context

interface LLMEngine {
    fun init(context: Context)
    fun generateReply(prompt: String): String
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/ReplyReason.kt =====
package com.jarvismini.engine

enum class ReplyReason {
    USER_BUSY,
    MISSED_MESSAGE,
    IMPORTANT_MESSAGE
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/ReplyToneResolver.kt =====
package com.jarvismini.engine

import com.jarvismini.core.JarvisMode

object ReplyToneResolver {

    fun resolve(reason: ReplyReason, mode: JarvisMode): String {
        return when (mode) {

            JarvisMode.WORK ->
                "This is Jarvis, assisting Mr. Aamir. He is currently in a meeting."

            JarvisMode.DRIVING ->
                "This is Jarvis, assisting Mr. Aamir. He is currently driving."

            JarvisMode.SLEEP ->
                "This is Jarvis, assisting Mr. Aamir. He is currently unavailable."

            JarvisMode.FOCUS ->
                "This is Jarvis, assisting Mr. Aamir. He is currently focused and unavailable."

            JarvisMode.NORMAL ->
                defaultByReason(reason)
        }
    }

    private fun defaultByReason(reason: ReplyReason): String {
        return when (reason) {
            ReplyReason.USER_BUSY ->
                "This is Jarvis, assisting Mr. Aamir. He is currently occupied and will respond when available."

            ReplyReason.MISSED_MESSAGE ->
                "This is Jarvis, assisting Mr. Aamir. He will review this message shortly."

            ReplyReason.IMPORTANT_MESSAGE ->
                "This is Jarvis, assisting Mr. Aamir. He has been notified and will respond as soon as possible."
        }
    }
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/StubCommandEngine.kt =====
package com.jarvismini.engine

object StubCommandEngine : CommandEngine {

    override fun canHandle(input: String): Boolean {
        return false
    }

    override fun handle(input: String): EngineResult {
        return EngineResult.Unhandled
    }
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/StubLLMEngine.kt =====
package com.jarvismini.engine

import android.content.Context

object StubLLMEngine : LLMEngine {

    override fun init(context: Context) {
        // No-op for stub
    }

    override fun generateReply(prompt: String): String {
        return "This is Jarvis. Mr. Aamir will respond shortly."
    }
}


===== FILE: modules/smart/build.gradle.kts =====
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.jarvismini.smart"
    compileSdk = 34

    defaultConfig {
        minSdk = 23
        targetSdk = 34
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}

dependencies {
    testImplementation("junit:junit:4.13.2")
}


===== FILE: modules/smart/proguard-rules.pro =====


===== FILE: modules/smart/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" />


===== FILE: modules/smart/src/main/kotlin/com/jarvismini/smart/ChatTypeDetector.kt =====
package com.jarvismini.smart

import android.view.accessibility.AccessibilityNodeInfo

/**
 * ChatTypeDetector: heuristics to detect group vs personal chat from AccessibilityNodeInfo.
 *
 * This tries several strategies:
 *  - check common WhatsApp view ids for group indicators
 *  - read toolbar/title node and look for participant patterns
 *  - scan visible text for keywords like "participants", "admins", etc.
 */
object ChatTypeDetector {

    private val groupKeywords = listOf(
        "participants",
        "admins",
        "member",
        "you joined",
        "added",
        "left",
        "Group"
    )

    /**
     * Return true if given window root looks like a group chat.
     * Accepts null root (returns false).
     */
    fun isGroupChat(root: AccessibilityNodeInfo?): Boolean {
        if (root == null) return false

        // 1. Try toolbar title nodes (common WhatsApp IDs)
        val toolbarIds = listOf(
            "com.whatsapp:id/conversation_contact_name",
            "com.whatsapp:id/contact_name",
            "com.whatsapp:id/toolbar_title"
        )

        for (id in toolbarIds) {
            try {
                val nodes = root.findAccessibilityNodeInfosByViewId(id)
                if (!nodes.isNullOrEmpty()) {
                    val txt = nodes.first().text?.toString() ?: ""
                    if (looksLikeGroupTitle(txt)) return true
                }
            } catch (_: Exception) {
                // ignore and continue
            }
        }

        // 2. Check for explicit group info container
        try {
            val groupInfo = root.findAccessibilityNodeInfosByViewId("com.whatsapp:id/group_info_container")
            if (!groupInfo.isNullOrEmpty()) return true
        } catch (_: Exception) { }

        // 3. Scan visible text for group keywords
        val texts = collectVisibleTexts(root, 200) // limit to avoid huge searches
        for (t in texts) {
            if (groupKeywords.any { kw -> t.contains(kw, ignoreCase = true) }) return true
        }

        return false
    }

    private fun looksLikeGroupTitle(title: String): Boolean {
        if (title.isBlank()) return false
        // groups often have count like "Family (10)" or include keywords
        if (title.contains("(") && title.contains(")")) return true
        return groupKeywords.any { title.contains(it, ignoreCase = true) }
    }

    private fun collectVisibleTexts(root: AccessibilityNodeInfo, limit: Int): List<String> {
        val out = mutableListOf<String>()
        fun walk(n: AccessibilityNodeInfo?) {
            if (n == null || out.size >= limit) return
            n.text?.let { if (it.isNotBlank()) out.add(it.toString()) }
            for (i in 0 until n.childCount) {
                val c = n.getChild(i) ?: continue
                walk(c)
            }
        }
        walk(root)
        return out
    }
}


===== FILE: modules/smart/src/main/kotlin/com/jarvismini/smart/CooldownManager.kt =====
package com.jarvismini.smart

/**
 * CooldownManager: per-chat cooldown to avoid spam.
 *
 * Usage:
 *  if (!CooldownManager.canReply(sender)) return
 *  // reply...
 *  CooldownManager.markReplied(sender)
 */
object CooldownManager {
    private val lastReply = mutableMapOf<String, Long>()
    private const val DEFAULT_COOLDOWN_MS = 8_000L

    /** Check whether we can reply to this sender now (does not modify state). */
    fun canReply(sender: String, cooldownMs: Long = DEFAULT_COOLDOWN_MS): Boolean {
        val now = System.currentTimeMillis()
        val prev = lastReply[sender] ?: 0L
        return (now - prev) >= cooldownMs
    }

    /** Mark that we've replied to this sender now. */
    fun markReplied(sender: String) {
        lastReply[sender] = System.currentTimeMillis()
    }

    /** Force-reset cooldown for a sender (useful for tests / admin). */
    fun reset(sender: String) {
        lastReply.remove(sender)
    }

    /** Clear all tracked state (useful for tests). */
    fun clearAll() {
        lastReply.clear()
    }
}


===== FILE: modules/smart/src/main/kotlin/com/jarvismini/smart/GroupDetection.kt =====
package com.jarvismini.smart

/**
 * GroupDetection: helper to determine group by sender name heuristics.
 * This is a lightweight fallback when AccessibilityNode root not available.
 */
object GroupDetection {

    private val groupNameIndicators = listOf("group", "team", "family", "friends", "community")

    /** Return true if the sender name strongly suggests a group. */
    fun isGroupByName(senderName: String?): Boolean {
        if (senderName == null) return false
        val s = senderName.lowercase().trim()
        if (s.isEmpty()) return false
        // typical "X (10)" style or presence of keywords
        if (s.contains("(") && s.contains(")")) return true
        return groupNameIndicators.any { s.contains(it) }
    }
}


===== FILE: modules/smart/src/main/kotlin/com/jarvismini/smart/RateLimiter.kt =====
package com.jarvismini.smart

import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger

/**
 * RateLimiter: a simple global rate limiter for total replies over time.
 *
 * Useful to limit Jarvis across all chats (e.g., max 10 replies per minute).
 */
class RateLimiter(private val windowMs: Long, private val maxEvents: Int) {

    private val events = ConcurrentHashMap<Long, AtomicInteger>()

    fun recordEvent(): Boolean {
        val now = System.currentTimeMillis()
        val bucket = now / windowMs
        events.putIfAbsent(bucket, AtomicInteger(0))
        val count = events[bucket]!!.incrementAndGet()
        // cleanup old buckets (simple)
        val keysToRemove = events.keys.filter { it < bucket - 2 }
        for (k in keysToRemove) events.remove(k)
        return count <= maxEvents
    }

    fun reset() {
        events.clear()
    }
}


===== FILE: modules/smart/src/main/kotlin/com/jarvismini/smart/SleepMode.kt =====
package com.jarvismini.smart

/**
 * SleepMode: a simple global "do not disturb" toggle.
 * You can later replace this with a user-set schedule or UI toggle.
 */
object SleepMode {
    @Volatile
    var enabled: Boolean = false

    /** Convenience: enable for N milliseconds (auto-disable). */
    fun enableFor(millis: Long) {
        enabled = true
        Thread {
            try {
                Thread.sleep(millis)
            } catch (_: InterruptedException) { }
            enabled = false
        }.start()
    }
}


===== FILE: modules/smart/src/main/kotlin/com/jarvismini/smart/SmartFilters.kt =====
package com.jarvismini.smart

/**
 * Minimal stub so module compiles.
 * Real logic will be added later.
 */
object SmartFilters {

    fun isAllowed(text: String): Boolean {
        return true
    }
}


===== FILE: modules/ui/MainActivity.kt =====
package com.jarvismini.ui

import android.app.Activity
import android.os.Bundle
import com.jarvismini.ui.R

class MainActivity : Activity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}


===== FILE: modules/ui/build.gradle.kts =====
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.jarvismini.ui"
    compileSdk = 34

    defaultConfig {
        minSdk = 23
        targetSdk = 34
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}

dependencies {
    // UI module should stay lightweight
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.appcompat:appcompat:1.6.1")
    implementation("com.google.android.material:material:1.11.0")
}


===== FILE: modules/ui/proguard-rules.pro =====


===== FILE: modules/ui/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" />


===== FILE: modules/ui/src/main/kotlin/com/jarvismini/ui/DebugPanel.kt =====


===== FILE: modules/ui/src/main/kotlin/com/jarvismini/ui/ViewBindings.kt =====
package com.jarvismini.ui

import android.app.Activity
import android.view.View

// Simple helper extension to keep your UI clean
fun <T : View> Activity.bind(id: Int): Lazy<T> = lazy { findViewById(id) }


===== FILE: modules/ui/src/main/kotlin/com/jarvismini/ui/settings/SettingsActivity.kt =====
package com.jarvismini.ui.settings

import android.app.Activity
import android.os.Bundle

class SettingsActivity : Activity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Minimal stub
    }
}


===== FILE: modules/ui/src/main/res/layout/activity_main.xml =====
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />


===== FILE: modules/ui/src/main/res/values/styles.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.JarvisMini" parent="Theme.Material3.DayNight.NoActionBar">
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="android:navigationBarColor">@android:color/black</item>
        <item name="android:windowBackground">@android:color/black</item>
    </style>
</resources>


===== FILE: gradle/wrapper/gradle-wrapper.properties =====
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.4-all.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

