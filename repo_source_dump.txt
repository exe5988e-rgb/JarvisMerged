================================
FILE TREE (SELECTED FOLDERS)
================================

.
├── app
│   ├── build.gradle.kts
│   ├── keystore
│   ├── proguard-rules.pro
│   ├── src
│   │   ├── androidTest
│   │   │   ├── java
│   │   │   │   ├── com
│   │   │   │   │   ├── jarvismini
│   │   │   │   │   │   ├── ExampleAndroidTest.kt
│   │   ├── debug
│   │   │   ├── java
│   │   │   │   ├── com
│   │   │   │   │   ├── jarvismini
│   │   │   │   │   │   ├── DebugBuildConfig.kt
│   │   ├── main
│   │   │   ├── AndroidManifest.xml
│   │   │   ├── kotlin
│   │   │   │   ├── com
│   │   │   │   │   ├── jarvismini
│   │   │   │   │   │   ├── AppAccessibilityService.kt
│   │   │   │   │   │   ├── BuildConfigBridge.kt
│   │   │   │   │   │   ├── CoreApp.kt
│   │   │   │   │   │   ├── MainActivity.kt
│   │   │   ├── res
│   │   │   │   ├── layout
│   │   │   │   │   ├── activity_main.xml
│   │   │   │   │   ├── activity_settings.xml
│   │   │   │   ├── values
│   │   │   │   │   ├── colors.xml
│   │   │   │   │   ├── strings.xml
│   │   │   │   │   ├── themes.xml
│   │   │   │   ├── xml
│   │   │   │   │   ├── accessibility_service_config.xml
│   │   ├── test
│   │   │   ├── java
│   │   │   │   ├── com
│   │   │   │   │   ├── jarvismini
│   │   │   │   │   │   ├── ExampleUnitTest.kt
├── modules
│   ├── automation
│   │   ├── build.gradle.kts
│   │   ├── proguard-rules.pro
│   │   ├── src
│   │   │   ├── main
│   │   │   │   ├── AndroidManifest.xml
│   │   │   │   ├── kotlin
│   │   │   │   │   ├── com
│   │   │   │   │   │   ├── jarvismini
│   │   │   │   │   │   │   ├── automation
│   │   │   │   │   │   │   │   ├── AutoCloser.kt
│   │   │   │   │   │   │   │   ├── AutoReplyContext.kt
│   │   │   │   │   │   │   │   ├── AutomationEngine.kt
│   │   │   │   │   │   │   │   ├── AutomationStubs.kt
│   │   │   │   │   │   │   │   ├── ChatOpener.kt
│   │   │   │   │   │   │   │   ├── MessageExtractor.kt
│   │   │   │   │   │   │   │   ├── ModeGuard.kt
│   │   │   │   │   │   │   │   ├── NodeFinder.kt
│   │   │   │   │   │   │   │   ├── SmartAutoReply.kt
│   │   │   │   │   │   │   │   ├── decision
│   │   │   │   │   │   │   │   │   ├── ReplyDecision.kt
│   │   │   │   │   │   │   │   ├── input
│   │   │   │   │   │   │   │   │   ├── AutoReplyInput.kt
│   │   │   │   │   │   │   │   ├── orchestrator
│   │   │   │   │   │   │   │   │   ├── AutoReplyOrchestrator.kt
│   ├── core
│   │   ├── build.gradle.kts
│   │   ├── proguard-rules.pro
│   │   ├── src
│   │   │   ├── main
│   │   │   │   ├── AndroidManifest.xml
│   │   │   │   ├── kotlin
│   │   │   │   │   ├── com
│   │   │   │   │   │   ├── jarvismini
│   │   │   │   │   │   │   ├── core
│   │   │   │   │   │   │   │   ├── CoreAppBridge.kt
│   │   │   │   │   │   │   │   ├── Extensions.kt
│   │   │   │   │   │   │   │   ├── JarvisMode.kt
│   │   │   │   │   │   │   │   ├── JarvisState.kt
│   │   │   │   │   │   │   │   ├── Logger.kt
│   │   │   │   │   │   │   │   ├── TimeUtils.kt
│   ├── engine
│   │   ├── build.gradle.kts
│   │   ├── proguard-rules.pro
│   │   ├── src
│   │   │   ├── main
│   │   │   │   ├── AndroidManifest.xml
│   │   │   │   ├── kotlin
│   │   │   │   │   ├── com
│   │   │   │   │   │   ├── jarvismini
│   │   │   │   │   │   │   ├── engine
│   │   │   │   │   │   │   │   ├── CommandEngine.kt
│   │   │   │   │   │   │   │   ├── CoreTag.kt
│   │   │   │   │   │   │   │   ├── EngineProvider.kt
│   │   │   │   │   │   │   │   ├── EngineResult.kt
│   │   │   │   │   │   │   │   ├── JarvisReplyGenerator.kt
│   │   │   │   │   │   │   │   ├── LLMEngine.kt
│   │   │   │   │   │   │   │   ├── ReplyReason.kt
│   │   │   │   │   │   │   │   ├── ReplyToneResolver.kt
│   │   │   │   │   │   │   │   ├── StubCommandEngine.kt
│   │   │   │   │   │   │   │   ├── StubLLMEngine.kt
│   ├── smart
│   │   ├── build.gradle.kts
│   │   ├── proguard-rules.pro
│   │   ├── src
│   │   │   ├── main
│   │   │   │   ├── AndroidManifest.xml
│   │   │   │   ├── kotlin
│   │   │   │   │   ├── com
│   │   │   │   │   │   ├── jarvismini
│   │   │   │   │   │   │   ├── smart
│   │   │   │   │   │   │   │   ├── ChatTypeDetector.kt
│   │   │   │   │   │   │   │   ├── CooldownManager.kt
│   │   │   │   │   │   │   │   ├── GroupDetection.kt
│   │   │   │   │   │   │   │   ├── RateLimiter.kt
│   │   │   │   │   │   │   │   ├── SleepMode.kt
│   │   │   │   │   │   │   │   ├── SmartFilters.kt
│   ├── ui
│   │   ├── MainActivity.kt
│   │   ├── build.gradle.kts
│   │   ├── proguard-rules.pro
│   │   ├── src
│   │   │   ├── main
│   │   │   │   ├── AndroidManifest.xml
│   │   │   │   ├── kotlin
│   │   │   │   │   ├── com
│   │   │   │   │   │   ├── jarvismini
│   │   │   │   │   │   │   ├── ui
│   │   │   │   │   │   │   │   ├── DebugPanel.kt
│   │   │   │   │   │   │   │   ├── ViewBindings.kt
│   │   │   │   │   │   │   │   ├── settings
│   │   │   │   │   │   │   │   │   ├── SettingsActivity.kt
│   │   │   │   ├── res
│   │   │   │   │   ├── layout
│   │   │   │   │   │   ├── activity_main.xml
│   │   │   │   │   ├── values
│   │   │   │   │   │   ├── styles.xml
├── gradle/wrapper
│   ├── gradle-wrapper.properties
├── scripts
│   ├── __init__.py
│   ├── error_parser.py
│   ├── extract_repo_to_txt.py
│   ├── git_utils.py
│   ├── github.py
│   ├── llm.py
│   ├── logger.py
│   ├── openrouter.py
│   ├── patch_applier.py
│   ├── pr_utils.py

================================
SOURCE CODE
================================

===== FILE: app/build.gradle.kts =====
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.jarvismini"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.jarvismini"
        minSdk = 26
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"
    }

    buildFeatures {
        viewBinding = true
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}

dependencies {
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.appcompat:appcompat:1.6.1")
    implementation("com.google.android.material:material:1.11.0")

    implementation(project(":modules:core"))
    implementation(project(":modules:automation"))
    implementation(project(":modules:engine"))
    implementation(project(":modules:smart"))
    implementation(project(":modules:ui"))
}


===== FILE: app/proguard-rules.pro =====


===== FILE: app/src/androidTest/java/com/jarvismini/ExampleAndroidTest.kt =====


===== FILE: app/src/debug/java/com/jarvismini/DebugBuildConfig.kt =====


===== FILE: app/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <application
        android:label="@string/app_name"
        android:icon="@android:drawable/sym_def_app_icon"
        android:allowBackup="true"
        android:supportsRtl="true"
        android:theme="@style/Theme.JarvisMini">

        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>

    </application>

</manifest>


===== FILE: app/src/main/kotlin/com/jarvismini/AppAccessibilityService.kt =====
package com.jarvismini

import android.accessibilityservice.AccessibilityService
import android.view.accessibility.AccessibilityEvent
import android.view.accessibility.AccessibilityNodeInfo
import com.jarvismini.automation.decision.ReplyDecision
import com.jarvismini.automation.input.AutoReplyInput
import com.jarvismini.automation.orchestrator.AutoReplyOrchestrator

class AppAccessibilityService : AccessibilityService() {

    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
        if (event == null) return

        if (event.eventType == AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED) {
            val source: AccessibilityNodeInfo? = event.source
            val messageText = source?.text?.toString()?.trim()
            if (messageText.isNullOrEmpty()) return

            val input = AutoReplyInput(
                messageText = messageText,
                isFromOwner = false
            )

            val decision = AutoReplyOrchestrator.handle(input)

            when (decision) {
                is ReplyDecision.AutoReply ->
                    println("Jarvis Auto-Reply: ${decision.message}")

                ReplyDecision.NoReply ->
                    println("Jarvis will not reply")
            }
        }
    }

    override fun onInterrupt() {
        // required
    }
}


===== FILE: app/src/main/kotlin/com/jarvismini/BuildConfigBridge.kt =====
package com.jarvismini

object BuildConfigBridge {
    const val IS_DEBUG = true
}


===== FILE: app/src/main/kotlin/com/jarvismini/CoreApp.kt =====
package com.jarvismini

import android.app.Application
import com.jarvismini.automation.orchestrator.AutoReplyOrchestrator
import com.jarvismini.core.JarvisMode
import com.jarvismini.core.JarvisState

class CoreApp : Application() {

    override fun onCreate() {
        super.onCreate()

        // Explicit default mode
        JarvisState.currentMode = JarvisMode.NORMAL

        AutoReplyOrchestrator.init()

        println("CoreApp started with mode: ${JarvisState.currentMode}")
    }
}


===== FILE: app/src/main/kotlin/com/jarvismini/MainActivity.kt =====
package com.jarvismini

import android.os.Bundle
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import com.jarvismini.automation.orchestrator.AutoReplyOrchestrator
import com.jarvismini.automation.input.AutoReplyInput
import com.jarvismini.automation.decision.ReplyDecision

/**
 * MainActivity now allows:
 * - Monitoring automation decisions
 * - Simulating incoming messages for testing
 */
class MainActivity : AppCompatActivity() {

    private lateinit var statusText: TextView
    private lateinit var simulateButton: Button

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Simple UI setup
        statusText = TextView(this).apply {
            textSize = 16f
            text = "Jarvis status will appear here"
            setPadding(24, 24, 24, 24)
        }

        simulateButton = Button(this).apply {
            text = "Simulate Incoming Message"
            setOnClickListener { simulateIncomingMessage() }
        }

        // Linear layout to hold text and button
        val layout = androidx.appcompat.widget.LinearLayoutCompat(this).apply {
            orientation = androidx.appcompat.widget.LinearLayoutCompat.VERTICAL
            addView(statusText)
            addView(simulateButton)
        }

        setContentView(layout)
    }

    /**
     * Simulate a new incoming message and run orchestrator
     */
    private fun simulateIncomingMessage() {
        val testMessage = "Hello Jarvis! Are you awake?"

        val input = AutoReplyInput(
            messageText = testMessage,
            isFromOwner = false
        )

        val decision = AutoReplyOrchestrator.handle(input)

        // Display the result
        when (decision) {
    is ReplyDecision.AutoReply ->
        statusText.text = "AutoReply: ${decision.message}"

    ReplyDecision.NoReply ->
        statusText.text = "No reply decision made"
        }
    }
}


===== FILE: app/src/main/res/layout/activity_main.xml =====
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

</LinearLayout>


===== FILE: app/src/main/res/layout/activity_settings.xml =====
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:padding="24dp"
    android:gravity="center"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Spinner
        android:id="@+id/modelSpinner"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:padding="12dp" />

</LinearLayout>


===== FILE: app/src/main/res/values/colors.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="purple_200">#BB86FC</color>
    <color name="purple_500">#6200EE</color>
    <color name="purple_700">#3700B3</color>
    <color name="teal_200">#03DAC5</color>
    <color name="black">#000000</color>
    <color name="white">#FFFFFF</color>
</resources>


===== FILE: app/src/main/res/values/strings.xml =====
<resources>
  <string name="app_name">Jarvis Merged</string>
  <string name="service_desc">Jarvis automation service for WhatsApp reply.</string>
</resources>


===== FILE: app/src/main/res/values/themes.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <style name="Theme.JarvisMerged" parent="Theme.Material3.DayNight.NoActionBar">
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="android:navigationBarColor">@android:color/black</item>
    </style>

</resources>


===== FILE: app/src/main/res/xml/accessibility_service_config.xml =====
<?xml version="1.0" encoding="utf-8"?>
<accessibility-service
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:accessibilityEventTypes="typeAllMask"
    android:accessibilityFeedbackType="feedbackGeneric"
    android:notificationTimeout="100"
    android:canRetrieveWindowContent="true" />


===== FILE: app/src/test/java/com/jarvismini/ExampleUnitTest.kt =====


===== FILE: modules/automation/build.gradle.kts =====
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.jarvismini.automation"
    compileSdk = 34

    defaultConfig {
        minSdk = 23
        targetSdk = 34
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}

dependencies {
    implementation(project(":modules:smart"))
    implementation(project(":modules:engine"))
    implementation(project(":modules:core"))
}


===== FILE: modules/automation/proguard-rules.pro =====


===== FILE: modules/automation/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" />


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/AutoCloser.kt =====
package com.jarvismini.automation

import android.view.accessibility.AccessibilityNodeInfo

object AutoCloser {
    fun closeChat(root: AccessibilityNodeInfo?) {
        val back = try {
            root?.findAccessibilityNodeInfosByViewId("com.whatsapp:id/back")
        } catch (_: Exception) { null }

        if (!back.isNullOrEmpty()) {
            back.first().performAction(AccessibilityNodeInfo.ACTION_CLICK)
        }
    }
}

===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/AutoReplyContext.kt =====
package com.jarvismini.automation

import com.jarvismini.engine.ReplyReason
import com.jarvismini.core.JarvisMode

data class AutoReplyContext(
    val reason: ReplyReason,
    val currentMode: JarvisMode,
    val isImportant: Boolean = false
)


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/AutomationEngine.kt =====
package com.jarvismini.automation

class AutomationEngine {

    fun generateReply(input: String): String {
        // STUB: real logic will come later
        return ""
    }

}


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/AutomationStubs.kt =====
package com.jarvismini.automation

fun ChatAllowed(): Boolean {
    return false
}

fun generateReply(text: String): String {
    return ""
}


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/ChatOpener.kt =====
package com.jarvismini.automation

import android.accessibilityservice.AccessibilityService
import android.util.Log
import android.view.accessibility.AccessibilityNodeInfo

object ChatOpener {

    private const val TAG = "JarvisMini-ChatOpener"

    private val unreadBadgeIds = listOf(
        "com.whatsapp:id/unread_indicator",
        "com.whatsapp:id/unread_count",
        "com.whatsapp:id/message_count"
    )

    fun openChat(service: AccessibilityService, root: AccessibilityNodeInfo?) {
        root ?: return

        // Try “new message”
        val nodes = root.findAccessibilityNodeInfosByText("new message")
        if (!nodes.isNullOrEmpty()) {
            nodes.first().performAction(AccessibilityNodeInfo.ACTION_CLICK)
            Log.i(TAG, "Opened chat via 'new message'")
            return
        }

        // Try unread badge
        for (id in unreadBadgeIds) {
            try {
                val badges = root.findAccessibilityNodeInfosByViewId(id)
                if (!badges.isNullOrEmpty()) {
                    badges.first().performAction(AccessibilityNodeInfo.ACTION_CLICK)
                    Log.i(TAG, "Opened chat via unread badge: $id")
                    return
                }
            } catch (_: Exception) {}
        }
    }
}

===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/MessageExtractor.kt =====
package com.jarvismini.automation

import android.view.accessibility.AccessibilityNodeInfo

/**
 * Extracts sender name + last received message text from WhatsApp.
 */
object MessageExtractor {

    private val chatTitleIds = listOf(
        "com.whatsapp:id/conversation_contact_name",
        "com.whatsapp:id/contact_name",
        "com.whatsapp:id/toolbar_title"
    )

    private val incomingMessageIds = listOf(
        "com.whatsapp:id/message_text",
        "com.whatsapp:id/message_text_in"
    )

    fun getSenderName(root: AccessibilityNodeInfo): String {
        chatTitleIds.forEach { id ->
            try {
                val list = root.findAccessibilityNodeInfosByViewId(id)
                if (!list.isNullOrEmpty()) {
                    return list.first().text?.toString()?.trim() ?: ""
                }
            } catch (_: Exception) {}
        }
        return ""
    }

    fun getLastIncomingMessage(root: AccessibilityNodeInfo): String {
        for (id in incomingMessageIds) {
            try {
                val nodes = root.findAccessibilityNodeInfosByViewId(id)
                if (!nodes.isNullOrEmpty()) {
                    // last element is latest chat message
                    return nodes.last().text?.toString() ?: ""
                }
            } catch (_: Exception) {}
        }
        return ""
    }
}


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/ModeGuard.kt =====
package com.jarvismini.automation

import com.jarvismini.core.JarvisMode
import com.jarvismini.core.JarvisState

object ModeGuard {

    fun allowsReply(): Boolean {
        return when (JarvisState.currentMode) {
            JarvisMode.NORMAL -> true
            JarvisMode.WORK -> true
            JarvisMode.DRIVING -> true
            JarvisMode.SLEEP -> false
            JarvisMode.FOCUS -> false
        }
    }
}


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/NodeFinder.kt =====
package com.jarvismini.automation

import android.util.Log
import android.view.accessibility.AccessibilityNodeInfo

/**
 * NodeFinder: Robust WhatsApp UI element detection.
 */
object NodeFinder {

    private const val TAG = "JarvisMini-NodeFinder"

    private val inputIds = listOf(
        "com.whatsapp:id/entry",
        "com.whatsapp:id/voice_note_text_input",
        "com.whatsapp:id/entry_container",
        "com.whatsapp:id/entry_text",
        "com.whatsapp:id/entry_input"
    )

    private val sendButtonIds = listOf(
        "com.whatsapp:id/send",
        "com.whatsapp:id/send_btn",
        "com.whatsapp:id/send_button",
        "com.whatsapp:id/send_icon",
        "com.whatsapp:id/send_message"
    )

    fun findInputField(root: AccessibilityNodeInfo): AccessibilityNodeInfo? {
        // 1️⃣ Try direct ID search
        for (id in inputIds) {
            safeFindById(root, id)?.firstOrNull()?.let {
                return it
            }
        }

        // 2️⃣ Try EditText fallback
        findByClass(root, "android.widget.EditText")?.let {
            return it
        }

        // 3️⃣ Try text input parents (some versions wrap it)
        for (id in inputIds) {
            safeFindById(root, id)?.firstOrNull()?.parent?.let { parent ->
                if (parent.className?.contains("EditText") == true)
                    return parent
            }
        }

        Log.w(TAG, "Input field not found")
        return null
    }

    fun findSendButton(root: AccessibilityNodeInfo): AccessibilityNodeInfo? {
        // 1️⃣ Direct ID search
        for (id in sendButtonIds) {
            safeFindById(root, id)?.firstOrNull()?.let {
                return it
            }
        }

        // 2️⃣ Fallback: ImageButton
        findByClass(root, "android.widget.ImageButton")?.let {
            return it
        }

        Log.w(TAG, "Send button not found")
        return null
    }

    private fun safeFindById(node: AccessibilityNodeInfo, id: String): List<AccessibilityNodeInfo>? {
        return try {
            node.findAccessibilityNodeInfosByViewId(id)
        } catch (_: Exception) {
            null
        }
    }

    private fun findByClass(node: AccessibilityNodeInfo, className: String): AccessibilityNodeInfo? {
        if (node.className == className) return node

        for (i in 0 until node.childCount) {
            val child = node.getChild(i) ?: continue
            findByClass(child, className)?.let { return it }
        }
        return null
    }
}


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/SmartAutoReply.kt =====
package com.jarvismini.automation

/**
 * STUB implementation.
 * Engine / LLM will be wired later.
 */
object SmartAutoReply {

    suspend fun generate(message: String): String {
        // TODO: connect to engine later
        return ""
    }
}


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/decision/ReplyDecision.kt =====
package com.jarvismini.automation.decision

/**
 * Final decision returned by automation layer.
 */
sealed class ReplyDecision {

    /**
     * Jarvis should auto-reply with this message.
     */
    data class AutoReply(
        val message: String
    ) : ReplyDecision()

    /**
     * Jarvis should not reply.
     */
    object NoReply : ReplyDecision()
}


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/input/AutoReplyInput.kt =====
package com.jarvismini.automation.input

data class AutoReplyInput(
    val messageText: String,
    val isFromOwner: Boolean
)


===== FILE: modules/automation/src/main/kotlin/com/jarvismini/automation/orchestrator/AutoReplyOrchestrator.kt =====
package com.jarvismini.automation.orchestrator

import com.jarvismini.automation.decision.ReplyDecision
import com.jarvismini.automation.input.AutoReplyInput
import com.jarvismini.core.JarvisMode
import com.jarvismini.core.JarvisState

/**
 * Orchestrates automation decisions for incoming messages.
 */
object AutoReplyOrchestrator {

    fun handle(input: AutoReplyInput): ReplyDecision {
        return when (JarvisState.currentMode) {
            JarvisMode.SLEEP,
            JarvisMode.FOCUS -> ReplyDecision.NoReply

            JarvisMode.DRIVING ->
                ReplyDecision.AutoReply(
                    message = "I'm driving right now. I'll respond soon."
                )

            JarvisMode.WORK ->
                ReplyDecision.AutoReply(
                    message = "I'm working at the moment. Will reply later."
                )

            JarvisMode.NORMAL ->
                ReplyDecision.NoReply
        }
    }

    fun init() {
        // future setup hook
    }
}


===== FILE: modules/core/build.gradle.kts =====
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.jarvismini.core"
    compileSdk = 34

    defaultConfig {
        minSdk = 23
        targetSdk = 34
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}


===== FILE: modules/core/proguard-rules.pro =====


===== FILE: modules/core/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" />


===== FILE: modules/core/src/main/kotlin/com/jarvismini/core/CoreAppBridge.kt =====
package com.jarvismini.core
object CoreAppBridge { fun appName() = "JarvisMerged" }


===== FILE: modules/core/src/main/kotlin/com/jarvismini/core/Extensions.kt =====
package com.jarvismini.core

fun String.trunc(n: Int): String =
    if (this.length > n) this.substring(0, n) else this


===== FILE: modules/core/src/main/kotlin/com/jarvismini/core/JarvisMode.kt =====
package com.jarvismini.core

enum class JarvisMode {
    NORMAL,
    WORK,
    DRIVING,
    SLEEP,
    FOCUS
}


===== FILE: modules/core/src/main/kotlin/com/jarvismini/core/JarvisState.kt =====
package com.jarvismini.core

object JarvisState {
    var currentMode: JarvisMode = JarvisMode.NORMAL
}


===== FILE: modules/core/src/main/kotlin/com/jarvismini/core/Logger.kt =====
package com.jarvismini.core

object Logger {
    fun i(tag: String, msg: String?) {
        android.util.Log.i(tag, msg ?: "")
    }
}


===== FILE: modules/core/src/main/kotlin/com/jarvismini/core/TimeUtils.kt =====
package com.jarvismini.core
object TimeUtils { fun nowMs() = System.currentTimeMillis() }


===== FILE: modules/engine/build.gradle.kts =====
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.jarvismini.engine"
    compileSdk = 34

    defaultConfig {
        minSdk = 24
        targetSdk = 34
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}

dependencies {
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3")
    implementation(project(":modules:core"))
}


===== FILE: modules/engine/proguard-rules.pro =====


===== FILE: modules/engine/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" />


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/CommandEngine.kt =====
package com.jarvismini.engine

interface CommandEngine {
    fun canHandle(input: String): Boolean
    fun handle(input: String): EngineResult
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/CoreTag.kt =====
package com.jarvismini.engine

object CoreTag {
    const val ENGINE = "ENGINE"
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/EngineProvider.kt =====
package com.jarvismini.engine

object EngineProvider {

    val commandEngine: CommandEngine = StubCommandEngine
    val llmEngine: LLMEngine = StubLLMEngine
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/EngineResult.kt =====
package com.jarvismini.engine

sealed class EngineResult {

    data class Success(
        val reply: String
    ) : EngineResult()

    object Unhandled : EngineResult()
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/JarvisReplyGenerator.kt =====
package com.jarvismini.engine

import com.jarvismini.core.JarvisMode

object JarvisReplyGenerator {

    fun generate(
        incomingMessage: String,
        reason: ReplyReason,
        mode: JarvisMode
    ): String {

        val baseReply = ReplyToneResolver.resolve(reason, mode)

        return "$baseReply\n\nMessage received: \"$incomingMessage\""
    }
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/LLMEngine.kt =====
package com.jarvismini.engine

import android.content.Context

interface LLMEngine {
    fun init(context: Context)
    fun generateReply(prompt: String): String
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/ReplyReason.kt =====
package com.jarvismini.engine

enum class ReplyReason {
    USER_BUSY,
    MISSED_MESSAGE,
    IMPORTANT_MESSAGE
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/ReplyToneResolver.kt =====
package com.jarvismini.engine

import com.jarvismini.core.JarvisMode

object ReplyToneResolver {

    fun resolve(reason: ReplyReason, mode: JarvisMode): String {
        return when (mode) {

            JarvisMode.WORK ->
                "This is Jarvis, assisting Mr. Aamir. He is currently in a meeting."

            JarvisMode.DRIVING ->
                "This is Jarvis, assisting Mr. Aamir. He is currently driving."

            JarvisMode.SLEEP ->
                "This is Jarvis, assisting Mr. Aamir. He is currently unavailable."

            JarvisMode.FOCUS ->
                "This is Jarvis, assisting Mr. Aamir. He is currently focused and unavailable."

            JarvisMode.NORMAL ->
                defaultByReason(reason)
        }
    }

    private fun defaultByReason(reason: ReplyReason): String {
        return when (reason) {
            ReplyReason.USER_BUSY ->
                "This is Jarvis, assisting Mr. Aamir. He is currently occupied and will respond when available."

            ReplyReason.MISSED_MESSAGE ->
                "This is Jarvis, assisting Mr. Aamir. He will review this message shortly."

            ReplyReason.IMPORTANT_MESSAGE ->
                "This is Jarvis, assisting Mr. Aamir. He has been notified and will respond as soon as possible."
        }
    }
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/StubCommandEngine.kt =====
package com.jarvismini.engine

object StubCommandEngine : CommandEngine {

    override fun canHandle(input: String): Boolean {
        return false
    }

    override fun handle(input: String): EngineResult {
        return EngineResult.Unhandled
    }
}


===== FILE: modules/engine/src/main/kotlin/com/jarvismini/engine/StubLLMEngine.kt =====
package com.jarvismini.engine

import android.content.Context

object StubLLMEngine : LLMEngine {

    override fun init(context: Context) {
        // No-op for stub
    }

    override fun generateReply(prompt: String): String {
        return "This is Jarvis. Mr. Aamir will respond shortly."
    }
}


===== FILE: modules/smart/build.gradle.kts =====
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.jarvismini.smart"
    compileSdk = 34

    defaultConfig {
        minSdk = 23
        targetSdk = 34
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}

dependencies {
    testImplementation("junit:junit:4.13.2")
}


===== FILE: modules/smart/proguard-rules.pro =====


===== FILE: modules/smart/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" />


===== FILE: modules/smart/src/main/kotlin/com/jarvismini/smart/ChatTypeDetector.kt =====
package com.jarvismini.smart

import android.view.accessibility.AccessibilityNodeInfo

/**
 * ChatTypeDetector: heuristics to detect group vs personal chat from AccessibilityNodeInfo.
 *
 * This tries several strategies:
 *  - check common WhatsApp view ids for group indicators
 *  - read toolbar/title node and look for participant patterns
 *  - scan visible text for keywords like "participants", "admins", etc.
 */
object ChatTypeDetector {

    private val groupKeywords = listOf(
        "participants",
        "admins",
        "member",
        "you joined",
        "added",
        "left",
        "Group"
    )

    /**
     * Return true if given window root looks like a group chat.
     * Accepts null root (returns false).
     */
    fun isGroupChat(root: AccessibilityNodeInfo?): Boolean {
        if (root == null) return false

        // 1. Try toolbar title nodes (common WhatsApp IDs)
        val toolbarIds = listOf(
            "com.whatsapp:id/conversation_contact_name",
            "com.whatsapp:id/contact_name",
            "com.whatsapp:id/toolbar_title"
        )

        for (id in toolbarIds) {
            try {
                val nodes = root.findAccessibilityNodeInfosByViewId(id)
                if (!nodes.isNullOrEmpty()) {
                    val txt = nodes.first().text?.toString() ?: ""
                    if (looksLikeGroupTitle(txt)) return true
                }
            } catch (_: Exception) {
                // ignore and continue
            }
        }

        // 2. Check for explicit group info container
        try {
            val groupInfo = root.findAccessibilityNodeInfosByViewId("com.whatsapp:id/group_info_container")
            if (!groupInfo.isNullOrEmpty()) return true
        } catch (_: Exception) { }

        // 3. Scan visible text for group keywords
        val texts = collectVisibleTexts(root, 200) // limit to avoid huge searches
        for (t in texts) {
            if (groupKeywords.any { kw -> t.contains(kw, ignoreCase = true) }) return true
        }

        return false
    }

    private fun looksLikeGroupTitle(title: String): Boolean {
        if (title.isBlank()) return false
        // groups often have count like "Family (10)" or include keywords
        if (title.contains("(") && title.contains(")")) return true
        return groupKeywords.any { title.contains(it, ignoreCase = true) }
    }

    private fun collectVisibleTexts(root: AccessibilityNodeInfo, limit: Int): List<String> {
        val out = mutableListOf<String>()
        fun walk(n: AccessibilityNodeInfo?) {
            if (n == null || out.size >= limit) return
            n.text?.let { if (it.isNotBlank()) out.add(it.toString()) }
            for (i in 0 until n.childCount) {
                val c = n.getChild(i) ?: continue
                walk(c)
            }
        }
        walk(root)
        return out
    }
}


===== FILE: modules/smart/src/main/kotlin/com/jarvismini/smart/CooldownManager.kt =====
package com.jarvismini.smart

/**
 * CooldownManager: per-chat cooldown to avoid spam.
 *
 * Usage:
 *  if (!CooldownManager.canReply(sender)) return
 *  // reply...
 *  CooldownManager.markReplied(sender)
 */
object CooldownManager {
    private val lastReply = mutableMapOf<String, Long>()
    private const val DEFAULT_COOLDOWN_MS = 8_000L

    /** Check whether we can reply to this sender now (does not modify state). */
    fun canReply(sender: String, cooldownMs: Long = DEFAULT_COOLDOWN_MS): Boolean {
        val now = System.currentTimeMillis()
        val prev = lastReply[sender] ?: 0L
        return (now - prev) >= cooldownMs
    }

    /** Mark that we've replied to this sender now. */
    fun markReplied(sender: String) {
        lastReply[sender] = System.currentTimeMillis()
    }

    /** Force-reset cooldown for a sender (useful for tests / admin). */
    fun reset(sender: String) {
        lastReply.remove(sender)
    }

    /** Clear all tracked state (useful for tests). */
    fun clearAll() {
        lastReply.clear()
    }
}


===== FILE: modules/smart/src/main/kotlin/com/jarvismini/smart/GroupDetection.kt =====
package com.jarvismini.smart

/**
 * GroupDetection: helper to determine group by sender name heuristics.
 * This is a lightweight fallback when AccessibilityNode root not available.
 */
object GroupDetection {

    private val groupNameIndicators = listOf("group", "team", "family", "friends", "community")

    /** Return true if the sender name strongly suggests a group. */
    fun isGroupByName(senderName: String?): Boolean {
        if (senderName == null) return false
        val s = senderName.lowercase().trim()
        if (s.isEmpty()) return false
        // typical "X (10)" style or presence of keywords
        if (s.contains("(") && s.contains(")")) return true
        return groupNameIndicators.any { s.contains(it) }
    }
}


===== FILE: modules/smart/src/main/kotlin/com/jarvismini/smart/RateLimiter.kt =====
package com.jarvismini.smart

import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicInteger

/**
 * RateLimiter: a simple global rate limiter for total replies over time.
 *
 * Useful to limit Jarvis across all chats (e.g., max 10 replies per minute).
 */
class RateLimiter(private val windowMs: Long, private val maxEvents: Int) {

    private val events = ConcurrentHashMap<Long, AtomicInteger>()

    fun recordEvent(): Boolean {
        val now = System.currentTimeMillis()
        val bucket = now / windowMs
        events.putIfAbsent(bucket, AtomicInteger(0))
        val count = events[bucket]!!.incrementAndGet()
        // cleanup old buckets (simple)
        val keysToRemove = events.keys.filter { it < bucket - 2 }
        for (k in keysToRemove) events.remove(k)
        return count <= maxEvents
    }

    fun reset() {
        events.clear()
    }
}


===== FILE: modules/smart/src/main/kotlin/com/jarvismini/smart/SleepMode.kt =====
package com.jarvismini.smart

/**
 * SleepMode: a simple global "do not disturb" toggle.
 * You can later replace this with a user-set schedule or UI toggle.
 */
object SleepMode {
    @Volatile
    var enabled: Boolean = false

    /** Convenience: enable for N milliseconds (auto-disable). */
    fun enableFor(millis: Long) {
        enabled = true
        Thread {
            try {
                Thread.sleep(millis)
            } catch (_: InterruptedException) { }
            enabled = false
        }.start()
    }
}


===== FILE: modules/smart/src/main/kotlin/com/jarvismini/smart/SmartFilters.kt =====
package com.jarvismini.smart

/**
 * Minimal stub so module compiles.
 * Real logic will be added later.
 */
object SmartFilters {

    fun isAllowed(text: String): Boolean {
        return true
    }
}


===== FILE: modules/ui/MainActivity.kt =====
package com.jarvismini.ui

import android.app.Activity
import android.os.Bundle
import com.jarvismini.ui.R

class MainActivity : Activity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
    }
}


===== FILE: modules/ui/build.gradle.kts =====
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.jarvismini.ui"
    compileSdk = 34

    defaultConfig {
        minSdk = 23
        targetSdk = 34
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}

dependencies {
    // UI module should stay lightweight
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.appcompat:appcompat:1.6.1")
    implementation("com.google.android.material:material:1.11.0")
}


===== FILE: modules/ui/proguard-rules.pro =====


===== FILE: modules/ui/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" />


===== FILE: modules/ui/src/main/kotlin/com/jarvismini/ui/DebugPanel.kt =====


===== FILE: modules/ui/src/main/kotlin/com/jarvismini/ui/ViewBindings.kt =====
package com.jarvismini.ui

import android.app.Activity
import android.view.View

// Simple helper extension to keep your UI clean
fun <T : View> Activity.bind(id: Int): Lazy<T> = lazy { findViewById(id) }


===== FILE: modules/ui/src/main/kotlin/com/jarvismini/ui/settings/SettingsActivity.kt =====
package com.jarvismini.ui.settings

import android.app.Activity
import android.os.Bundle

class SettingsActivity : Activity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Minimal stub
    }
}


===== FILE: modules/ui/src/main/res/layout/activity_main.xml =====
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent" />


===== FILE: modules/ui/src/main/res/values/styles.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.JarvisMini" parent="Theme.Material3.DayNight.NoActionBar">
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="android:navigationBarColor">@android:color/black</item>
        <item name="android:windowBackground">@android:color/black</item>
    </style>
</resources>


===== FILE: gradle/wrapper/gradle-wrapper.properties =====
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.4-all.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

